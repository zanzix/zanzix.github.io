<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Some personal notes turned into a blog</title>
    <link href="https://zanzix.github.io/atom.xml" rel="self" type="application/rss+xml" />
  <updated>2023-08-10T14:53:01Z</updated>
  <author>
      <name>Zanzi</name>
  </author>
  <id>https://zanzix.github.io/</id>

  <entry>
      <title>From Fixpoint of Functor to Operad</title>
      <link href="https://zanzix.github.ioposts/from-functor-to-operad.html"/>
      <id>https://zanzix.github.ioposts/from-functor-to-operad.html</id>
      <updated>2023-08-10T00:00:00Z</updated>
      <category term="functor"/>
      <category term="fixpoint"/>
      <category term="operad"/>
      <summary>Lets start the blog</summary>
      <content type="html"><![CDATA[<ul>
<li>start with a definition of a recursive type, ie List, and then
extract the base functor</li>
</ul>
<p>First, lets introduce the fixpoint of an endofunctor</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu</span> <span class="ot">:</span> (<span class="kw">pattern</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>	<span class="dt">In</span> <span class="ot">:</span> {f<span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> f (<span class="dt">Mu</span> f) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f</span></code></pre></div>
<p>We can build expressions with it</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>example expressions</span></code></pre></div>
<p>to evaluate them, we define a notion of algebra</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Algebra</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Algebra</span> f a <span class="fu">=</span> f a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>and we define a catamorphism, or a fold, which uniformly evaluates
any 'f' that's a functor</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cata</span> <span class="ot">:</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>cata alg (<span class="dt">In</span> op) <span class="fu">=</span> alg (map (cata alg) op)</span></code></pre></div>
<p>TODO: Try doing this with mendler-style eval which doesn't rely on
Functor</p>
<p>Now, this gives us a notion of closed expression. We can represent
algebraic signatures, say, Monoids, Semirings, and we can evaluate
them.</p>
<p>But it doesn't quite feel like universal algebra, since we don't have
variables. To get variables, we move up a level of abstraction. Instead
of using fixpoints over endofunctors, we work with free monads.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> <span class="ot">:</span> (<span class="kw">pattern</span><span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)) <span class="ot">-&gt;</span> (var<span class="ot">:</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>	<span class="dt">Var</span> <span class="ot">:</span> var <span class="ot">-&gt;</span> <span class="dt">Free</span> pat var</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>	<span class="dt">In</span> <span class="ot">:</span> pat (<span class="dt">Free</span> pat var) <span class="ot">-&gt;</span> <span class="dt">Free</span> pat var</span></code></pre></div>
<p>The only thing that's changed is that we've added the extra
constructor Var, and the extra type-variable into the type of Free</p>
<p>Indeed, Mu f = Free f Void and Free f a = Mu (f + Const)</p>
<p>But the perspective is valuable, because previously, we took a
functor to a value</p>
<p>Functor : Type -&gt; Type Functor a = a -&gt; a</p>
<p>Mu : (Functor Type) -&gt; Type</p>
<p>Whereas Free takes a functor to a functor</p>
<p>Free : (Functor Type) -&gt; (Functor Type)</p>
<p>What this means in practice is that we can now construct terms with
variables</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>example terms</span></code></pre></div>
<p>and our evaluator takes an extra parameter, to know how to handle
variables</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mcata</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Algebra</span> f c <span class="ot">-&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> c</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>mcata g alg <span class="fu">=</span> go <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="fu">go</span> <span class="ot">:</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> c</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>go (<span class="dt">Var</span> a) <span class="fu">=</span> g a</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>go (<span class="dt">In</span> <span class="fu">$</span> fs) <span class="fu">=</span> alg <span class="fu">$</span> (mcata g alg) fs</span></code></pre></div>
<p>This is nice, but unfortunately our function mcata is now partial,
since our terms are not well scoped</p>
<p>To fix this, we can change our domain from c to 'Maybe c', or maybe
some other exception-uandling monad m</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">partialEval</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Algebra</span> f c <span class="ot">-&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> m c</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>partialEval g alg <span class="fu">=</span> go <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">go</span> <span class="ot">:</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> c</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>go (<span class="dt">Var</span> a) <span class="fu">=</span> pure <span class="fu">$</span> g a</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>go (<span class="dt">In</span> <span class="fu">$</span> fs) <span class="fu">=</span> alg <span class="fu">$</span> (mcata g alg) fs</span></code></pre></div>
<p>And indeed, this is a common way of doings things in Haskell. But it
doesn't solve the problem, it just pushes it into the codomain.</p>
<p>Since we're using dependent types, we can go a step further, and
define well-scoped terms by construction.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Operad</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="kw">where</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Var</span> <span class="ot">:</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Operad</span> f n a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="dt">LetF</span> <span class="ot">:</span> f (<span class="dt">Operad</span> f (<span class="dt">S</span> n) a) <span class="ot">-&gt;</span> <span class="dt">Operad</span> f n a</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="dt">LetBind</span> <span class="ot">:</span> f a <span class="ot">-&gt;</span> <span class="dt">Operad</span> f (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> <span class="dt">Operad</span> f n a)</span></code></pre></div>
<p>TODO: might need to change it to Nat -&gt; Type -&gt; Type to be more
regular? it'd make it consistent with typed languages: List Ty -&gt; Ty
-&gt; Type</p>
<p>This time, our Var constructor is bound by Fin. Instead of working
with an infinite set of variable, we work with a finite set of variables
at a time.</p>
<p>And whereas previously Bind would append a functorial layer into a
monad, now it binds it to a variable S. * mention that operad is no
longer a functor between functors, but between a functor and an indexed
functor</p>
<p>Let's look at some example expressions</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>examples</span></code></pre></div>
<p>Now our evaluator looks like this</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mcata</span> <span class="ot">:</span> (<span class="dt">Fin</span> n <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Algebra</span> f c <span class="ot">-&gt;</span> <span class="dt">Operad</span> f n <span class="ot">-&gt;</span> c</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>mcata g alg <span class="fu">=</span> go <span class="kw">where</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="fu">go</span> <span class="ot">:</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> c</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>go (<span class="dt">Var</span> a) <span class="fu">=</span> g a</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>go (<span class="dt">In</span> <span class="fu">$</span> fs) <span class="fu">=</span> alg <span class="fu">$</span> (mcata g alg) fs</span></code></pre></div>
<p>The cool thing about this is that our evaluator hardly changed.</p>
<p>While Operad is no longer a monad, it's a free <em>relative</em>
monad. Aka, a monad relative to Fin.</p>
<p>But we can form relative monads over other types as well. What they
give us, is a very general notion of binding with respect to some
context.</p>
<p>We will come back to relative monads soon, but for now let's look at
the common abstraction that underlies all of these constructions.</p>
<p>But before we can do that, we need to generalise slightly.</p>]]></content>
  </entry>
  <entry>
      <title>Fixpoints all the way up</title>
      <link href="https://zanzix.github.ioposts/higher-fixpoints.html"/>
      <id>https://zanzix.github.ioposts/higher-fixpoints.html</id>
      <updated>2023-08-10T00:00:00Z</updated>
      <category term="functor"/>
      <category term="fixpoint"/>
      <category term="operad"/>
      <summary>Lets start the blog</summary>
      <content type="html"><![CDATA[<h1 id="higher-order-fixpoint">Higher order fixpoint</h1>
<p>Last blog post we looked at fixpoints over endofunctors, free monads,
and free operads.</p>
<p>It might seem like a lot of concepts.</p>
<p>But the secret is that they're all instances of the same thing...</p>
<p>Let's start with the free monad</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>	<span class="dt">Var</span> <span class="ot">:</span> v <span class="ot">-&gt;</span> <span class="dt">Free</span> f v</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>	<span class="dt">In</span> <span class="ot">:</span> f (<span class="dt">Free</span> f v) <span class="ot">-&gt;</span> <span class="dt">Free</span> f v</span></code></pre></div>
<p>We can notice a similarity with the type of Lists, and ineed a free
monad is just a list 'one level up'.</p>
<p>So what happens if, just as we did in the first blog post, we extract
the recursive component of Free?</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FreeF</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>	<span class="dt">Var</span> <span class="ot">:</span> v <span class="ot">-&gt;</span> <span class="dt">Free</span> f g v</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>	<span class="dt">In</span> <span class="ot">:</span> f (g v) <span class="ot">-&gt;</span> <span class="dt">Free</span> f g v</span></code></pre></div>
<p>Rewriting the types a litte, we can see the clear link with ListF</p>
<p>FreeF : Functor Type -&gt; Functor Type -&gt; Functor Type ListF :
Type -&gt; Type -&gt; Type</p>
<p>In fact, if we change the arrows a little</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">(:~&gt;)</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>(<span class="ot">:</span><span class="fu">~&gt;</span>) f g <span class="fu">=</span> {a <span class="ot">:</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>We will see that</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Var</span> <span class="ot">:</span> <span class="dt">I</span> <span class="ot">:</span><span class="fu">~&gt;</span> <span class="dt">Free</span> f g </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">In</span> <span class="ot">:</span> f g <span class="fu">~&gt;</span> <span class="dt">Free</span> f g</span></code></pre></div>
<p>Looks a lot like</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode idris"><code class="sourceCode idris"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Nil</span> <span class="ot">:</span> () <span class="ot">-&gt;</span> <span class="dt">ListF</span> a b</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Cons</span> <span class="ot">:</span> (a, b) <span class="ot">-&gt;</span> <span class="dt">ListF</span> a b</span></code></pre></div>
<p>With the main difference is that ListF is a monoid with respect to
the cartesian product, while FreeF is a monoid with respect to functor
composition (It is in fact a <em>category</em> with respect to functor
composition, but we will get to that later...)</p>
<p>Since Free is a functor, specifically in the category of
endofunctors, it will have a corresponding notion of fixpoint</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu2</span> <span class="ot">:</span> (<span class="kw">pattern</span><span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>	<span class="dt">In2</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> f (<span class="dt">Mu</span> f) a <span class="ot">-&gt;</span> <span class="dt">Mu</span> f a</span></code></pre></div>
<p>We can see that it's just Mu one level up</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Mu2</span> <span class="ot">:</span> (<span class="dt">Functor</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Functor</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Functor</span> <span class="dt">Type</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Mu</span> <span class="ot">:</span>  (        <span class="dt">Type</span> <span class="ot">-&gt;</span>         <span class="dt">Type</span>) <span class="ot">-&gt;</span>         <span class="dt">Type</span></span></code></pre></div>
<p>As a fixpoint of endofunctor, Mu2 will also have its own notion of
algebra</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Algebra</span> <span class="ot">:</span> (f <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (a <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Algebra</span> f a <span class="fu">=</span> f a <span class="ot">:</span><span class="fu">~&gt;</span> a</span></code></pre></div>
<p>or more simply</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Algebra</span> <span class="ot">:</span> (<span class="dt">Functor</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Functor</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Functor</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>And a notion of fold</p>
<pre><code>cata : Functor2 hf =&gt; (hf f :~&gt; f) -&gt; Mu hf :~&gt; f

cata alg (In op) = alg (maph (cata alg) op)
</code></pre>
<p>Now, the evaluator for Mu2 gives us a <em>functor</em>, not a
<em>value</em></p>
<p>So if we want to recover our previous evaluator, we need to
post-compose it with a first-order evaluator</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Algebra2</span> (<span class="dt">FreeF</span>) (<span class="dt">Fix</span> <span class="dt">List</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>eval <span class="fu">=</span> fold alg (fold alg2 expr) </span></code></pre></div>
<p>The advantage of this approach is that we separate our evaluation.
The monadic stage covers variable binding and substitution, and the
functor stage covers evaluating the expression itself</p>
<p>We can also evaluate our expression into a value directly, using the
konstant functor</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Algebra2</span> (<span class="dt">FreeF</span>) (<span class="dt">Konst</span> <span class="dt">Nat</span>)</span></code></pre></div>
<h1 id="indexed-fixpoint">Indexed fixpoint</h1>
<p>Our operad is also an example of a higher-order fixpoint</p>
<p>This time, instead of functors over the category of functors, we take
functors over the category of indexed functors</p>
<p>as before, we extract our recursive component</p>
<pre><code>data Operad : (Type -&gt; Type) -&gt; (Nat -&gt; Type -&gt; Type) -&gt; (Nat -&gt; Type -&gt; Type) where 

	Var : Fin n -&gt; Operad f g n a

	LetF : f (g (S n) a) -&gt; Operad f g n a

-- (Type -&gt; Type) -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type </code></pre>
<div class="sourceCode" id="cb14"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu</span> <span class="ot">:</span> ((k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>)) <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>	<span class="dt">In</span> <span class="ot">:</span> f (<span class="dt">Mu</span> f) n a <span class="ot">-&gt;</span> <span class="dt">Mu</span> f n a</span></code></pre></div>
<p>TODO: Does this actually work?</p>
<p>and we evaluate it</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>cata </span></code></pre></div>
<p>The nice thing about this type is that it works over our regular
data-types (Type -&gt; Type),</p>
<p>but if we want a more regualr fixpoint, we could also do</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu</span> <span class="ot">:</span> ((k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>)) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>	<span class="dt">In</span> <span class="ot">:</span> f (<span class="dt">Mu</span> f) a <span class="ot">-&gt;</span> <span class="dt">Mu</span> f a</span></code></pre></div>
<p>and we can recover our Operad by setting k = (Nat, Type)</p>
<p>TODO: pattern for free relative monad?</p>
<p>So the purpose of this blog post was to introduce higher-order
fixpoint, and show how they subsume both free monads and free
operads.</p>
<p>And since, as we learned from the previous blog post, we can upgrade
Mu to Free, the same is true of Mu2 and IxMu</p>
<p>For Mu2, we get Free2</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- data Free :  (Functor Type -&gt; Functor Type) -&gt; Functor Type -&gt; Functor Type</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- this might be wrong</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> <span class="ot">:</span> (<span class="kw">pattern</span><span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)) <span class="ot">-&gt;</span> (var<span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (value<span class="ot">:</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Var</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> v a <span class="ot">-&gt;</span> <span class="dt">Free</span> f v a</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="dt">In2</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> f (<span class="dt">Free</span> f v) a <span class="ot">-&gt;</span> <span class="dt">Free</span> f v a</span></code></pre></div>
<p>Whereas a first-order free monad has variables that range over
values, a second-order free monad has variables that range over
functors.</p>
<p>And for MuIx, we get FreeIx</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FreeI</span> <span class="ot">:</span> (<span class="kw">pattern</span><span class="ot">:</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>)) <span class="ot">-&gt;</span> (con<span class="ot">:</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (value<span class="ot">:</span> k) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Var</span> <span class="ot">:</span> {a <span class="ot">:</span> k} <span class="ot">-&gt;</span> con a <span class="ot">-&gt;</span> <span class="dt">FreeI</span> f con a</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="dt">In2</span> <span class="ot">:</span> {a <span class="ot">:</span> k} <span class="ot">-&gt;</span> f (<span class="dt">FreeI</span> f con) a <span class="ot">-&gt;</span> <span class="dt">FreeI</span> f con a</span></code></pre></div>]]></content>
  </entry>
  <entry>
      <title>Fixpoints all the way up</title>
      <link href="https://zanzix.github.ioposts/indexed-fixpoints.html"/>
      <id>https://zanzix.github.ioposts/indexed-fixpoints.html</id>
      <updated>2023-08-10T00:00:00Z</updated>
      <category term="functor"/>
      <category term="fixpoint"/>
      <category term="operad"/>
      <summary>Lets start the blog</summary>
      <content type="html"><![CDATA[<p>In the previous blog posts, we've looked at free operads for
well-scoped domain specific languages. A natural question to ask, is
what would it mean to have a well-typed language?</p>
<p>TODO: Start with Type -&gt; Type instead of Ty-&gt;Type and show that
we can extract the recursive component just as well</p>
<p>We will look at it in this blog post.</p>
<p>Let's say we have a simple language, with Booleans and Arithmetic</p>
<p>First we define our types</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty</span> <span class="fu">=</span> <span class="dt">BOOL</span> <span class="fu">|</span> <span class="dt">NAT</span></span></code></pre></div>
<p>Then we define our data type, indexed by the types</p>
<pre><code>data BoolArith : Ty -&gt; Type 

V1 : interpTy type -&gt; BoolArith1 type

AddNat : BoolArith1 NAT -&gt; BoolArith1 NAT -&gt; BoolArith1 NAT

Conj : BoolArith1 BOOL -&gt; BoolArith1 BOOL -&gt; BoolArith1 BOOL
</code></pre>
<p>We could write a custom evaluator for our well-typed DSL</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evalBA1</span> <span class="ot">:</span> <span class="dt">BoolArith1</span> t <span class="ot">-&gt;</span> interpTy t</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>evalBA1 (<span class="dt">V1</span> t) <span class="fu">=</span> t</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>evalBA1 (<span class="dt">AddNat</span> e1 e2) <span class="fu">=</span> (evalBA1 e1) <span class="fu">+</span> (evalBA1 e2)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>evalBA1 (<span class="dt">Conj</span> e1 e2) <span class="fu">=</span> (evalBA1 e1) <span class="fu">&amp;&amp;</span> (evalBA1 e2)</span></code></pre></div>
<p>But instead we'd like to use our general machinery</p>
<p>So as always, we start by extracting the recursive component</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BoolArithF</span> <span class="ot">:</span> (<span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">VF</span> <span class="ot">:</span> interpTy type <span class="ot">-&gt;</span> <span class="dt">BoolArithF</span> r type</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">AddF</span> <span class="ot">:</span> r <span class="dt">NAT</span> <span class="ot">-&gt;</span> r <span class="dt">NAT</span> <span class="ot">-&gt;</span> <span class="dt">BoolArithF</span> r <span class="dt">NAT</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">ConjF</span> <span class="ot">:</span> r <span class="dt">BOOL</span> <span class="ot">-&gt;</span> r <span class="dt">BOOL</span> <span class="ot">-&gt;</span> <span class="dt">BoolArithF</span> r <span class="dt">BOOL</span></span></code></pre></div>
<p>We can see that (Ty -&gt; Type) is an indexed data type, so
BoolArithF is an endofunctor over indexed types</p>
<p>BoolArithF : Functor (Ty -&gt; Type)</p>
<p>So to tie the recursive knot, we need a fixpoint over an indexed
endofunctor</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu</span> <span class="ot">:</span> ((k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>)) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dt">In</span> <span class="ot">:</span> f (<span class="dt">Mu</span> f) a <span class="ot">-&gt;</span> <span class="dt">Mu</span> f a</span></code></pre></div>
<p>So now we recover our previous data-type</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">BoolArith</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">BoolArith</span> <span class="fu">=</span> (<span class="dt">Mu</span> <span class="dt">BoolArithF</span>)</span></code></pre></div>
<p>If we want to evaluate our typed expressions, we can do it just as
before.</p>
<pre><code>example of eval</code></pre>
<p>This is neat, but as in chapter 1, this only gives us closed
expressions.</p>
<p>But what if we want our expression language to have variables? ref:
<a href="https://tyde.systems/post/2019-12-04-razor/"
class="uri">https://tyde.systems/post/2019-12-04-razor/</a></p>
<p>As we've seen before, to add variables we need to go from Mu to Free,
and to make the variables well-scoped, we need to go from Free to
Operad.</p>
<p>Let's do that straight away.</p>
<p>However, what we notice is that while previously our type was</p>
<p>Operad : (Nat -&gt; Type -&gt; Type)</p>
<p>this is no longer sufficient for our purposes. Since we have more
than one type, we need a more expressive scope than Fin</p>
<p>So what we can notice is that Nat is isomorphic to a list over a
one-element set Nat == List Unit</p>
<p>So if we want to go from an untyped language to a typed one, we
generalise our scope from Nat to List Matching the intuition that an
untyped language is the same as a language with a single type. Or more
accurately, a well-scoped language is a typed language with a single
type.</p>
<p>So generalising from Nat to List, our constructor for well-typed
expressions would look like this</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RazorST</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>	<span class="dt">Let</span> <span class="ot">:</span> <span class="dt">RazorST</span> ctxt a <span class="ot">-&gt;</span> <span class="dt">RazorST</span> (a<span class="ot">::</span>ctxt) b <span class="ot">-&gt;</span> <span class="dt">RazorST</span> ctxt b</span></code></pre></div>
<p>extracting the recursive component</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RazorF</span> <span class="ot">:</span> (<span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>	<span class="dt">Let</span> <span class="ot">:</span> f ctxt a <span class="ot">-&gt;</span> f (a<span class="ot">::</span>ctxt) b <span class="ot">-&gt;</span> <span class="dt">RazorST</span> ctxt b</span></code></pre></div>
<p>A multi-object operad is often called a coloured operad, a
multi-sorted algebraic theory. They're also often called a
multi-category, but I would make a distinction that a coloured operad is
an operad over a finite number of types. A full-fledged multicategory,
is an operad over an inductively defined set of types.</p>
<p>But we will get to that later.</p>]]></content>
  </entry>
  <entry>
      <title>From Mendler Algebra to Relative Monads</title>
      <link href="https://zanzix.github.ioposts/mendler-algebra.html"/>
      <id>https://zanzix.github.ioposts/mendler-algebra.html</id>
      <updated>2023-08-10T00:00:00Z</updated>
      <category term="functor"/>
      <category term="fixpoint"/>
      <category term="operad"/>
      <summary>Lets start the blog</summary>
      <content type="html"><![CDATA[<p>So far we've relied on all of our underlying data-types to have a
valid instance.</p>
<p>But as we intend to generalise a <em>lot</em>, this kind of
constraint will lead to far too much boilerplate.</p>
<p>Luckily, we can generalise this away.</p>
<p>TODO: Try my trick of doing cata with no functor constraint?</p>
<p>Interestingly, we can do it in two different ways. We can either
modify our notion of algebra, as is common in the recursion-schemes
literature</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">MAlgebra</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MAlgebra</span> f c <span class="fu">=</span> {x <span class="ot">:</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f x <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>Letting us keep the same type of fixpoint Mu,</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fold</span> <span class="ot">:</span> <span class="dt">MAlgebra</span> </span></code></pre></div>
<p>Or we can modify our notion of the data-type, as is more common in
the free-monad literature</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Freer</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>	<span class="dt">Var</span> <span class="ot">:</span> v <span class="ot">-&gt;</span> <span class="dt">Freerf</span> f v</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>	<span class="dt">Bind</span> <span class="ot">:</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> <span class="dt">Freer</span> f v) <span class="ot">-&gt;</span> <span class="dt">Freer</span> f v</span></code></pre></div>
<p>It turns out that both of these techniques are related.</p>
<p>we can look at Coyoneda,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Coyoneda</span> <span class="ot">:</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">InCoyo</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Coyoneda</span> f b</span></code></pre></div>
<p>we can notice that MAlgebra f a = Algebra (Coyoneda f) a</p>
<p>and we can also see that</p>
<p>Freer f a = Freer (Cyoneda f) a</p>
<p>from this, we can even derive a notion of 'freer fixpoint'</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu</span> <span class="ot">:</span> (<span class="kw">pattern</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> <span class="ot">:</span> {f<span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> <span class="dt">Coyoneda</span> f (<span class="dt">Mu</span> f) <span class="ot">-&gt;</span> <span class="dt">Mu</span> </span></code></pre></div>
<p>So this gives us a version of Fix and Free that does not rely on an
underlying functor instance</p>
<p>But what about Op?</p>
<p>As I mentioned in the last post, Op is not a free monad, but a free
<em>relative</em> monad.</p>
<p>The trick to deriving this is to notice that Coyoneda is a special
case of a left kan extension, Coyoneda = Lan Id, and that a standard
monad is a monad w.r.t to the Identity functor. As it turns out, these
two facts are related.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Lan</span> <span class="ot">:</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>	<span class="dt">InLan</span></span></code></pre></div>
<p>so given a context functor j : (k-&gt;Type), the free relative monad
over j is given by</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode idr"><code class="sourceCode idris"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Relative</span> <span class="ot">:</span> {j <span class="ot">:</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="dt">PureR</span> <span class="ot">:</span> {j <span class="ot">:</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> j x <span class="ot">-&gt;</span> <span class="dt">Relative</span> j f x</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">ThenR</span> <span class="ot">:</span> {j <span class="ot">:</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> f x <span class="ot">-&gt;</span> (j x <span class="ot">-&gt;</span> <span class="dt">Relative</span> j f a) <span class="ot">-&gt;</span> <span class="dt">Relative</span> j f a</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Bind</span> <span class="ot">:</span> <span class="dt">Lan</span> j f (<span class="dt">Mu</span> j f v) <span class="ot">-&gt;</span> <span class="dt">Mu</span> j f v</span></code></pre></div>
<p>our evaluator now uses a new algebra and a new data-type</p>
<pre><code>cata : {j : k -&gt; Type} -&gt; (j n -&gt; c) -&gt; Algebra (Lan j f) c -&gt; Mu j f n -&gt; c
cata g alg = go where

go : Mu j f n -&gt; c

go (Var a) = g a

go (Bind $ MkLan continue action) = alg (MkLan (go . continue) action)</code></pre>
<p>TODO: Will this work with last post's notion of operad (Type -&gt;
Type) -&gt; (Nat -&gt; Type -&gt; Type) ?</p>
<p>LetF : f (Operad f (S n) a) -&gt; Operad f n a LetF : Coyoneda f
(Operad f (S n) a) -&gt; Operad f n a</p>
<p>LetBind : f a -&gt; Operad f (S n) a -&gt; Operad f n a)</p>]]></content>
  </entry>
</feed>

<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml"
      xmlns:fb="http://ogp.me/ns/fb#">
<head profile="http://www.w3.org/2005/10/profile">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-6WEVP6B3NL"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-6WEVP6B3NL');
    </script>    
    <meta property="og:image" content="/images/small-bibby.png" />
    <meta charset="UTF-8">
    <meta name="description" content="Some personal notes turned into a blog">
    <meta name="author" content="Jules Hedges">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@tangled_zans">
<meta name="twitter:creator" content="@tangled_zans">
<meta name="twitter:title" content="Well-Typed Substructural Languages">
    <meta name="twitter:description" content="Implementing well-typed by construction substructural languages">
        <title>Well-Typed Substructural Languages</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
</head>
<body>
    <header>
        <nav>
            <a id="beacon" href="/">
                <div id="home-text"> HOME </div>
            </a>
        </nav>
    
        <div class="right-sidebar">
    
            <a class="ext-link" href="https://twitter.com/tangled_zans">
            <img src="/images/twitter-logo.png" alt="Twitter Profile"/>
        </a>
        <a class="ext-link" rel="me" href="https://mathstodon.xyz/@zanzi">
                <img src="/images/mastodon-logo.svg" alt="Mastodon Profile"/>
              </a>        
        <div id="theme-button">DAY</div>
        </div>
    </header>

<div id="page">
    <div class="wrapper">
        <div class="masthead">
            <span class="title">
                Well-Typed Substructural Languages
            </span>
            <br>

            <br>
            <span class="byline">by Jules Hedges</span>
            <br>
            <span class="date">Aug 26, 2024</span>
            <br>
            <div class="metadata">
            </div>
            <div class="tags">
            </div>
        </div>
    </div>
    <article class="post">
        <p>Guest post by <a href="https://julesh.com/">Jules Hedges</a></p>
<p>In this post I'll explain how to build well-typed by construction
implementations of substructural languages, that is, languages in which
our ability to delete, copy and/or swap variables in scope is
restricted. I will begin by recounting the folklore that I learned from
Conor Mc Bride and Zanzi, and then I will explain a useful trick that I
invented: terms that are parametrised by an action of a category of
context morphisms.</p>
<p>Personally, my main interest in this topic comes from my plans to
implement a bidirectional programming language in which all programs are
<a href="https://arxiv.org/abs/1703.10857">optics</a>, so they can be
run in both a forwards mode and a backwards mode. Due to the subtle
categorical structure of optics, such a programming language is
substructural in a very unique and complicated way. I have found in
practice that actions of context morphisms help a lot to make this
problem tractable. I'll be continuing to document my development of this
language on the <a href="https://cybercat.institute/">CyberCat Institute
blog</a>.</p>
<p>We begin with a tiny language for types, with monoidal products (a
neutral name because later we will be making it behave like different
kinds of product), a unit type to be the neutral element of the monoidal
product, and a "ground" type that is intended to contain some nontrivial
values.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty</span> <span class="op">:</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Unit</span> <span class="op">:</span> <span class="dt">Ty</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ground</span> <span class="op">:</span> <span class="dt">Ty</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tensor</span> <span class="op">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span></span></code></pre></div>
<h2 id="cartesian-terms">Cartesian terms</h2>
<p>Although we have used the name "tensor", suppose we want to make an
ordinary cartesian language where variables can be implicitly copied and
discarded. Here is a standard way to do it: it is an intuitionistic
natural deduction calculus.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- A variable is a term if we can point to it in scope</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="op">:</span> <span class="dt">Elem</span> x xs <span class="ot">-&gt;</span> <span class="dt">Term</span> xs x</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Unit is always a term in every scope</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitIntro</span> <span class="op">:</span> <span class="dt">Term</span> xs <span class="dt">Unit</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Pattern matching on Unit, redunant here but kept for comparison to later</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitElim</span> <span class="op">:</span> <span class="dt">Term</span> xs <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">Term</span> xs x</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- A pair is a term if each side is a term</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="op">:</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">Term</span> xs y <span class="ot">-&gt;</span> <span class="dt">Term</span> xs (<span class="dt">Tensor</span> x y)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Pattern matching on a pair, adding both sides to the scope</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="op">:</span> <span class="dt">Term</span> xs (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">x :: y ::</span> xs) z <span class="ot">-&gt;</span> <span class="dt">Term</span> xs z</span></code></pre></div>
<p>The constructor for <code>Var</code> uses <code>Elem</code>, a
standard library type that defines pointers into a list:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Elem</span> <span class="op">:</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Here</span> <span class="op">:</span> <span class="dt">Elem</span> x (<span class="ot">x ::</span> xs)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">There</span> <span class="op">:</span> <span class="dt">Elem</span> x xs <span class="ot">-&gt;</span> <span class="dt">Elem</span> x (<span class="ot">x&#39; ::</span> xs)</span></code></pre></div>
<p>Here are some examples of programs we can write in this language:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- \x =&gt; ()</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>delete <span class="op">:</span> <span class="dt">CartesianTerm</span> [a] <span class="dt">Unit</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>delete <span class="ot">=</span> <span class="dt">UnitIntro</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- \(x, y) =&gt; x</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>prjl <span class="op">:</span> <span class="dt">CartesianTerm</span> [a, b] a</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>prjl <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Here</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- \(x, y) =&gt; y</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>prjr <span class="op">:</span> <span class="dt">CartesianTerm</span> [a, b] b</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>prjr <span class="ot">=</span> <span class="dt">Var</span> (<span class="dt">There</span> <span class="dt">Here</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- \x =&gt; (x, x)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>copy <span class="op">:</span> <span class="dt">CartesianTerm</span> [a] (<span class="dt">Tensor</span> a a)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>copy <span class="ot">=</span> <span class="dt">TensorIntro</span> (<span class="dt">Var</span> <span class="dt">Here</span>) (<span class="dt">Var</span> <span class="dt">Here</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- \(x, y) =&gt; (y, x)</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>swap <span class="op">:</span> <span class="dt">CartesianTerm</span> [a, b] (<span class="dt">Tensor</span> b a)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>swap <span class="ot">=</span> <span class="dt">TensorIntro</span> (<span class="dt">Var</span> (<span class="dt">There</span> <span class="dt">Here</span>)) (<span class="dt">Var</span> <span class="dt">Here</span>)</span></code></pre></div>
<p>The thing that makes this language cartesian and allows us to write
these 3 terms is the way that the context <code>xs</code> gets shared by
the inputs of the different term constructors. In the next section we
will define terms a different way, and then none of these examples will
typecheck.</p>
<h2 id="planar-terms">Planar terms</h2>
<p>Next let's go to the opposite extreme and build a fully substructural
language, in which we cannot delete or copy or swap. I learned how to do
this from Conor Mc Bride and Zanzi. Here is the idea:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- A variable is a term only if it is the only thing in scope</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="op">:</span> <span class="dt">Term</span> [x] x</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Unit is a term only in the empty scope</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitIntro</span> <span class="op">:</span> <span class="dt">Term</span> [] <span class="dt">Unit</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Pattern matching on Unit consumes its scope</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitElim</span> <span class="op">:</span> <span class="dt">Term</span> xs <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> (xs <span class="op">++</span> ys) y</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Constructing a pair consumes the scopes of both sides</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="op">:</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> (xs <span class="op">++</span> ys) (<span class="dt">Tensor</span> x y)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Pattern matching on a pair consumes its scope</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="op">:</span> <span class="dt">Term</span> xs (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">x :: y ::</span> ys) z <span class="ot">-&gt;</span> <span class="dt">Term</span> (xs <span class="op">++</span> ys) z</span></code></pre></div>
<p>This is a semantically correct definition of planar terms and it
would work if we had a sufficiently smart typechecker, but for the
current generation of dependent typecheckers we can't use this
definition because it suffers from what's called <em>green slime</em>.
The problem is that we have types containing terms that involve the
recursive function <code>++</code>, and the typechecker will get stuck
when this function tries to pattern match on a free variable. (I have no
idea how you learn this if you don't happen to drink in the same pubs as
Conor. Dependently typed programming has a catastrophic lack of books
that teach it.)</p>
<p>The fix is that we need to define a datatype that witnesses that the
concatenation of two lists is equal to a third list - a witness that the
composition of two things is equal to a third thing is called a
<em>simplex</em>. The key idea is that this datatype exactly reflects
the recursive structure of <code>++</code>, but as a relation rather
than a function:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Simplex</span> <span class="op">:</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> <span class="op">:</span> <span class="dt">Simplex</span> [] ys ys</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> <span class="op">:</span> <span class="dt">Simplex</span> xs ys zs <span class="ot">-&gt;</span> <span class="dt">Simplex</span> (<span class="ot">x ::</span> xs) ys (<span class="ot">x ::</span> zs)</span></code></pre></div>
<p>Now we can write a definition of planar terms that we can work
with:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="op">:</span> <span class="dt">Term</span> [x] x</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitIntro</span> <span class="op">:</span> <span class="dt">Term</span> [] <span class="dt">Unit</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitElim</span> <span class="op">:</span> <span class="dt">Simplex</span> xs ys zs </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Term</span> xs <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> zs y</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="op">:</span> <span class="dt">Simplex</span> xs ys zs </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> zs (<span class="dt">Tensor</span> x y)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="op">:</span> <span class="dt">Simplex</span> xs ys zs </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> xs (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">x :: y ::</span> ys) z <span class="ot">-&gt;</span> <span class="dt">Term</span> zs z</span></code></pre></div>
<p>This language is so restricted that it's hard to show it doing
anything, but here is one example of a term we can write:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- \(x, y) =&gt; (x, y)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>foo <span class="op">:</span> <span class="dt">Term</span> [a, b] (<span class="dt">Tensor</span> a b)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="dt">TensorIntro</span> (<span class="dt">Left</span> <span class="dt">Right</span>) <span class="dt">Var</span> <span class="dt">Var</span></span></code></pre></div>
<p>Manually defining simplicies, which cut a context into two halves, is
very good as a learning exercise but eventually gets irritating. We can
direct Idris to search for the simplex automatically:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="op">:</span> <span class="dt">Term</span> [x] x</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitIntro</span> <span class="op">:</span> <span class="dt">Term</span> [] <span class="dt">Unit</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitElim</span> <span class="op">:</span> {auto prf <span class="op">:</span> <span class="dt">Simplex</span> xs ys zs} </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Term</span> xs <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> zs y</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="op">:</span> {auto prf <span class="op">:</span> <span class="dt">Simplex</span> xs ys zs} </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> zs (<span class="dt">Tensor</span> x y)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="op">:</span> {auto prf <span class="op">:</span> <span class="dt">Simplex</span> xs ys zs} </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> xs (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">x :: y ::</span> ys) z <span class="ot">-&gt;</span> <span class="dt">Term</span> zs z</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>foo <span class="op">:</span> <span class="dt">Term</span> [a, b] (<span class="dt">Tensor</span> a b)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span></span></code></pre></div>
<p>This works, but I find that the proof search gets confused easily
(although it works fine for the baby examples in this post), so let's
pull out the big guns and write a tactic:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> <span class="op">:</span> (xs, ys <span class="op">:</span> <span class="dt">List</span> a) <span class="ot">-&gt;</span> (zs <span class="op">:</span> <span class="dt">List</span> a <span class="op">**</span> <span class="dt">Simplex</span> xs ys zs)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> [] ys <span class="ot">=</span> (ys <span class="op">**</span> <span class="dt">Right</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">concat</span> (<span class="ot">x ::</span> xs) ys <span class="ot">=</span> <span class="kw">let</span> (zs <span class="op">**</span> s) <span class="ot">=</span> <span class="fu">concat</span> xs ys <span class="kw">in</span> (<span class="ot">x ::</span> zs <span class="op">**</span> <span class="dt">Left</span> s)</span></code></pre></div>
<p>This function takes two lists and returns their concatenation
together with a simplex that witnesses this fact. Here <code>**</code>
is Idris syntax for both the type former and term former for dependent
pair (aka. Sigma) types.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="op">:</span> <span class="dt">Term</span> [x] x</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitIntro</span> <span class="op">:</span> <span class="dt">Term</span> [] <span class="dt">Unit</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitElim</span> <span class="op">:</span> {xs, ys <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> {default (<span class="fu">concat</span> xs ys) prf <span class="op">:</span> (zs <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="op">**</span> <span class="dt">Simplex</span> xs ys zs)}</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Term</span> xs <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> prf<span class="op">.</span><span class="fu">fst</span> y</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="op">:</span> {xs, ys <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> {default (<span class="fu">concat</span> xs ys) prf <span class="op">:</span> (zs <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="op">**</span> <span class="dt">Simplex</span> xs ys zs)}</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">Term</span> ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> prf<span class="op">.</span><span class="fu">fst</span> (<span class="dt">Tensor</span> x y)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="op">:</span> {xs, ys <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> {default (<span class="fu">concat</span> xs ys) prf <span class="op">:</span> (zs <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="op">**</span> <span class="dt">Simplex</span> xs ys zs)} </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> xs (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">x :: y ::</span> ys) z <span class="ot">-&gt;</span> <span class="dt">Term</span> prf<span class="op">.</span><span class="fu">fst</span> z</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>foo <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [a, b] (<span class="dt">Tensor</span> a b)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span></span></code></pre></div>
<p>I find Idris' <code>default</code> syntax to be a bit awkward, but it
feels to me like a potentially very powerful tool, and something I wish
Haskell had for scripting instance search.</p>
<h2 id="context-morphisms">Context morphisms</h2>
<p>Unfortunately, going from a planar language to a linear one - that
is, ruling out copy and delete but allowing swaps - is much harder. I
figured out a technique for doing this that turns out to be very
powerful and give very fine control over the scoping rules of a
language.</p>
<p>The idea is to isolate a category of context morphisms (technically a
coloured <a href="https://ncatlab.org/nlab/show/PRO">pro</a>, that is a
strict monoidal category whose monoid of objects is free). Then we will
parametrise a planar language by an action of this category. The good
news is that this is the final iteration of the definition of
<code>Term</code>, and we'll be working with it for the rest of this
blog post.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Structure</span> <span class="op">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Structure</span> a <span class="ot">=</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="op">:</span> <span class="dt">Structure</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="op">:</span> <span class="dt">Term</span> hom [x] x</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Act</span> <span class="op">:</span> hom xs ys <span class="ot">-&gt;</span> <span class="dt">Term</span> hom ys x <span class="ot">-&gt;</span> <span class="dt">Term</span> hom xs x</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitIntro</span> <span class="op">:</span> <span class="dt">Term</span> hom [] <span class="dt">Unit</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitElim</span> <span class="op">:</span> {xs, ys <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> {default (<span class="fu">concat</span> xs ys) prf <span class="op">:</span> (zs <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="op">**</span> <span class="dt">Simplex</span> xs ys zs)}</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Term</span> hom xs <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> hom ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> hom prf<span class="op">.</span><span class="fu">fst</span> y</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="op">:</span> {xs, ys <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span>}</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> {default (<span class="fu">concat</span> xs ys) prf <span class="op">:</span> (zs <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="op">**</span> <span class="dt">Simplex</span> xs ys zs)}</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Term</span> hom xs x <span class="ot">-&gt;</span> <span class="dt">Term</span> hom ys y <span class="ot">-&gt;</span> <span class="dt">Term</span> hom prf<span class="op">.</span><span class="fu">fst</span> (<span class="dt">Tensor</span> x y)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="op">:</span> {xs, ys <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> {default (<span class="fu">concat</span> xs ys) prf <span class="op">:</span> (zs <span class="op">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="op">**</span> <span class="dt">Simplex</span> xs ys zs)} </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> hom xs (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> hom (<span class="ot">x :: y ::</span> ys) z </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> hom prf<span class="op">.</span><span class="fu">fst</span> z</span></code></pre></div>
<p>First, let's recover planar terms. To do this, we want to define a
<code>Structure</code> where <code>hom xs ys</code> is a proof that
<code>xs = ys</code>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Planar</span> <span class="op">:</span> <span class="dt">Structure</span> a <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Empty</span> <span class="op">:</span> <span class="dt">Planar</span> [] []</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Whisker</span> <span class="op">:</span> <span class="dt">Planar</span> xs ys <span class="ot">-&gt;</span> <span class="dt">Planar</span> (<span class="ot">x ::</span> xs) (<span class="ot">x ::</span> ys)</span></code></pre></div>
<p>Now let's deal with linear terms. For that, we want to define a
<code>Structure</code> where <code>hom xs ys</code> is a proof that
<code>ys</code> is a permutation of <code>xs</code>. We can do this in
two steps:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Insertion x xs ys is a witness that ys consists of xs with x inserted somewhere</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Insertion</span> <span class="op">:</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The insertion is at the head of the list</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Here</span> <span class="op">:</span> <span class="dt">Insertion</span> x xs (<span class="ot">x ::</span> xs)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The insertion is somewhere in the tail of the list</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">There</span> <span class="op">:</span> <span class="dt">Insertion</span> x xs ys <span class="ot">-&gt;</span> <span class="dt">Insertion</span> x (<span class="ot">y ::</span> xs) (<span class="ot">y ::</span> ys)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Symmetric</span> <span class="op">:</span> <span class="dt">Structure</span> a <span class="kw">where</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The empty list has a unique permutation to itself</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Empty</span> <span class="op">:</span> <span class="dt">Symmetric</span> [] []</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Extend a permutation by inserting the head element into the permuted tail</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Insert</span> <span class="op">:</span> <span class="dt">Insertion</span> x ys zs <span class="ot">-&gt;</span> <span class="dt">Symmetric</span> xs ys <span class="ot">-&gt;</span> <span class="dt">Symmetric</span> (<span class="ot">x ::</span> xs) zs</span></code></pre></div>
<p>(Incidentally, this is the point where I realised that although Idris
<em>looks</em> like Haskell, programming in it feels a lot closer to
programming in Prolog.)</p>
<p>Now we write swap as term:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>swap <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Symmetric</span> [a, b] (<span class="dt">Tensor</span> b a)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>swap <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Insert</span> (<span class="dt">There</span> <span class="dt">Here</span>) (<span class="dt">Insert</span> <span class="dt">Here</span> <span class="dt">Empty</span>)) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span></code></pre></div>
<h2 id="explicitly-cartesian-terms">Explicitly cartesian terms</h2>
<p>Now we can come full circle and redefine cartesian terms in a way
that uniformly matches the way we do substructural terms.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Cartesian</span> <span class="op">:</span> <span class="dt">Structure</span> a <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Delete everything in scope</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Delete</span> <span class="op">:</span> <span class="dt">Cartesian</span> xs []</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Point to a variable in scope and make a copy on top</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Copy</span> <span class="op">:</span> <span class="dt">Elem</span> y xs <span class="ot">-&gt;</span> <span class="dt">Cartesian</span> xs ys <span class="ot">-&gt;</span> <span class="dt">Cartesian</span> xs (<span class="ot">y ::</span> ys)</span></code></pre></div>
<p>With this, we can rewrite all the terms we started with:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>delete <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Cartesian</span> [a] <span class="dt">Unit</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>delete <span class="ot">=</span> <span class="dt">Act</span> <span class="dt">Delete</span> <span class="dt">UnitIntro</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>prjl <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Cartesian</span> [a, b] a</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>prjl <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> <span class="dt">Here</span> <span class="dt">Delete</span>) <span class="dt">Var</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>prjr <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Cartesian</span> [a, b] b</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>prjr <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> (<span class="dt">There</span> <span class="dt">Here</span>) <span class="dt">Delete</span>) <span class="dt">Var</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>copy <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Cartesian</span> [a] (<span class="dt">Tensor</span> a a)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>copy <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> <span class="dt">Here</span> (<span class="dt">Copy</span> <span class="dt">Here</span> <span class="dt">Delete</span>)) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>swap <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Cartesian</span> [a, b] (<span class="dt">Tensor</span> b a)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>swap <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> (<span class="dt">There</span> <span class="dt">Here</span>) (<span class="dt">Copy</span> <span class="dt">Here</span> <span class="dt">Delete</span>)) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span></code></pre></div>
<p>Let's end with a party trick. What would a <em>cocartesian</em>
language look like - one where we can't delete or copy, but we can spawn
and merge?</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Co</span> <span class="op">:</span> <span class="dt">Structure</span> a <span class="ot">-&gt;</span> <span class="dt">Structure</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Co</span> hom xs ys <span class="ot">=</span> hom ys xs</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- spawn : Void -&gt; a</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- spawn = \case {}</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>spawn <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Co</span> <span class="dt">Cartesian</span>) [] a</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>spawn <span class="ot">=</span> <span class="dt">Act</span> <span class="dt">Delete</span> <span class="dt">Var</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- merge : Either a a -&gt; a</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- merge = \case {Left x =&gt; x; Right x =&gt; x}</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>merge <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Co</span> <span class="dt">Cartesian</span>) [a, a] a</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>merge <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> <span class="dt">Here</span> (<span class="dt">Copy</span> <span class="dt">Here</span> <span class="dt">Delete</span>)) <span class="dt">Var</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- injl : a -&gt; Either a b</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- injl = \x =&gt; Left x</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>injl <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Co</span> <span class="dt">Cartesian</span>) [a] (<span class="dt">Tensor</span> a b)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>injl <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> <span class="dt">Here</span> <span class="dt">Delete</span>) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- injr : b -&gt; Either a b</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- injr = \y =&gt; Right y</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>injr <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Co</span> <span class="dt">Cartesian</span>) [b] (<span class="dt">Tensor</span> a b)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>injr <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> (<span class="dt">There</span> <span class="dt">Here</span>) <span class="dt">Delete</span>) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span></code></pre></div>
<p>Since at the very beginning we added a single generating type
<code>Ground</code>, and the category generated by one object and finite
coproducts is finite sets and functions, this language can define
exactly the functions between finite sets. For example, there are
exactly 4 functions from booleans to booleans:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span>, false, true, <span class="fu">not</span> <span class="op">:</span> <span class="dt">Term</span> (<span class="dt">Co</span> <span class="dt">Cartesian</span>) [<span class="dt">Ground</span>, <span class="dt">Ground</span>] (<span class="dt">Tensor</span> <span class="dt">Ground</span> <span class="dt">Ground</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> <span class="dt">Here</span> (<span class="dt">Copy</span> (<span class="dt">There</span> <span class="dt">Here</span>) <span class="dt">Delete</span>)) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>false <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> <span class="dt">Here</span> (<span class="dt">Copy</span> <span class="dt">Here</span> <span class="dt">Delete</span>)) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>true <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> (<span class="dt">There</span> <span class="dt">Here</span>) (<span class="dt">Copy</span> (<span class="dt">There</span> <span class="dt">Here</span>) <span class="dt">Delete</span>)) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span> <span class="ot">=</span> <span class="dt">Act</span> (<span class="dt">Copy</span> (<span class="dt">There</span> <span class="dt">Here</span>) (<span class="dt">Copy</span> <span class="dt">Here</span> <span class="dt">Delete</span>)) (<span class="dt">TensorIntro</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span></code></pre></div>
<p>That's enough for today, but next time I will continue using this
style of term language to start dealing with the difficult issues of
building a programming language for optics.</p>

        <br>
        <br>

        <!--Share buttons-->
        <div class="social-buttons">
            <a href="https://twitter.com/share" class="twitter-share-button"
                                                data-url="https://zanzix.github.io" data-text="Check out: Well-Typed Substructural Languages - " data-via="tangled_zans">Tweet</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
            <a href="https://twitter.com/tangled_zans" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @tangled_zans</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
            <div class="fb-like" data-href="" data-layout="button" data-action="like" data-show-faces="true" data-share="true"></div>
        </div>
</article>

</div>

<footer>
    Built with Haskell using <a href="https://github.com/ChrisPenner/slick">slick</a> ❤️
</footer>

<link href='https://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
<script src="/js/main.js"></script>
</body>
</html>
